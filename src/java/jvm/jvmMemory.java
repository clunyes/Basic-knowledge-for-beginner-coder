package java.jvm;

public class jvmMemory {
    /**
     * 线程私有的：
     *
     *     程序计数器
     *
     *     另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，
     *     我们称这类内存区域为“线程私有”的内存。
     *     程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
     *
     *    虚拟机栈
     *    Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。StackOverFlowError：
     *    若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，
     *    就抛出StackOverFlowError异常。OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，
     *    无法再动态扩展了，此时抛出OutOfMemoryError异常。
     *

     *
     *     本地方法栈
     *
     *     虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
     *
     * 线程共享的：
     *
     *     堆
     *
     *     此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
     *
     *     Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，
     *     由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：
     *     再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。
     *
     *     方法区(元空间)
     *
     *     方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。
     *
     *     整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，
     *     受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。
     */

    /**
     *
     * 堆内存中对象的分配的基本策略
     *
     * 上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。
     * 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，
     * 并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），
     * 就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。
     *
     */

    /**
     * Minor Gc和Full GC 有什么不同呢？
     * 大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
     * 新生代GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
     * 老年代GC（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。
     *

     */

}
