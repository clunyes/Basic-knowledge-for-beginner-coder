package java.core;

public class hotspot {
    /**
     * 1.线程栈：线程创建是会为每个线程创建一个线程栈，线程栈里面会为每个方法调用创建一个栈帧。主要用于保存线程的当前运行状态。
     *
     * 2.堆：用于存放运行时中生成的新对像。会划分成新生代和老年代。新生代里面又划分成了eden区、存活1区和存活2区。
     *
     * 3.永久区：方法和常量区，用于存放方法字节码元数据和各种常量。
     */

    /**
     * 1.内存回收策略和常见概念
     *
     * 常见内存回收策略可以从以下几个维度来理解：
     *
     * 1.1 串行&并行
     * 串行：单线程执行内存回收工作。十分简单，无需考虑同步等问题，但耗时较长，不适合多cpu。
     * 并行：多线程并发进行回收工作。适合多CPU，效率高。
     * 1.2 并发& stop the world
     * stop the world：jvm里的应用线程会挂起，只有垃圾回收线程在工作进行垃圾清理工作。简单，无需考虑回收不干净等问题。
     * 并发：在垃圾回收的同时，应用也在跑。保证应用的响应时间。会存在回收不干净需要二次回收的情况。
     * 1.3 压缩&非压缩&copy
     * 压缩：在进行垃圾回收后，会通过滑动，把存活对象滑动到连续的空间里，清理碎片，保证剩余的空间是连续的。
     * 非压缩：保留碎片，不进行压缩。
     *
     * copy：将存活对象移到新空间，老空间全部释放。（需要较大的内存。）
     */

    /**
     * 触发GC的时机
     *
     * 最后总结一下什么时候会触发一次GC，个人经验看，有三种场景会触发GC：
     *
     * 1、第一种场景应该很明显，当年轻代或者老年代满了，Java虚拟机无法再为新的对象分配内存空间了，
     * 那么Java虚拟机就会触发一次GC去回收掉那些已经不会再被使用到的对象
     *
     * 2、手动调用System.gc_old()方法，通常这样会触发一次的Full GC以及至少一次的Minor GC
     *
     * 3、程序运行的时候有一条低优先级的GC线程，它是一条守护线程，当这条线程处于运行状态的时候，
     * 自然就触发了一次GC了。这点也很好证明，不过要用到WeakReference的知识，后面写WeakReference的时候会专门讲到这个。
     */

    /**
     * Serial 复制算法
     * SerialOld
     * ParNew:serial的多线程版本
     * Parallel：高吞吐量，适合计算任务之类的 标记整理法
     * ParOld
     * CMS：低pauseTime，webapp  标记-清除
     * 当Old或Perm区空间不足时，会触发Full GC
     *
     * 参考资料：https://www.cnblogs.com/zedosu/p/6666903.html
     */
}
