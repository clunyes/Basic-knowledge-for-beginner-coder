package javatest.jvm.内存结构;

public class jvmMemory {
    /**
     * 线程私有的：
     *
     *     1.程序计数器（线程私有）
     *
     *     为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，
     *     我们称这类内存区域为“线程私有”的内存。
     *     程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
     *
     *    2. 虚拟机栈（线程私有）
     *
     *    与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。
     *    虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）
     *
     *    用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，
     *    就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
     *
     * Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。StackOverFlowError：
     *

     *
     *     3. 本地方法栈（线程私有）
     *
     *     虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
     *
     * 线程共享的：
     *
     *     4. 堆（共享）
     *
     *     此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
     *
     *     Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，
     *     由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：
     *     再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。
     *
     *     5. 方法区（共享）
     *
     *     用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。更具体的说，静态变量+常量+类信息
     *     （版本、方法、字段等）+运行时常量池存在方法区中。常量池是方法区的一部分。
     *      JDK1.8 使用元空间 MetaSpace 替代方法区，元空间并不在 JVM中，而是使用本地内存。
     */

}
