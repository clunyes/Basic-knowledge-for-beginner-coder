package javatest.jvm.垃圾回收;

public class gc方法 {
    /**
     * GC的三种收集方法：标记清除、标记整理、复制算法
     *
     * 1. 标记清除算法
     * 分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
     * 它主要有两个问题：一个是效率问题，标记清除的效率较低；第二个是碎片问题，清除后会产生大量不连续的内存碎片。
     *
     * 2. 复制算法—回收新生代，回收比例较大
     *
     * 原理就是把内存划分为大小相等的两块，每次只使用其中的一块。当这一块上的内存用完了，
     * 就把还存活的对象（可达性分析）复制到另一块上，然后把已使用过的内存空间一次性清理掉，
     * 这样每次都不用考虑内存碎片的情况，并且实现的更加简单。如果存活的比例很低，那么复制的操作就很小，效率会比较高。
     * 只是如果一次只使用其中一半，那么代价太大了。
     *
     * 现在主要都是用于新生代的回收，98%的新生代对象都是很快就不用的，
     * 所以只需要把内存分为一块较大的Eden空间和两块Survivor空间，每次只使用Eden和一块Survivor空间，
     * 当回收时把两个区域存活的对象复制到那一块剩余的Survivor上。一般比例为8:1，这样浪费的空间只有10%。
     * 如果Survivor内存不够，就是用老年代的内存进行担保。
     *
     * 3. 标记整理算法—回收老年代，回收比例较小
     *
     * 对于老年代，存活的比例一般会比较高，如果使用复制算法那么复制操作的效率就会比较低。
     * 根据老年代的特点，提出了标记整理算法，先标记需要回收的对象；
     * 第二部不是进行回收，而是将存活对象都移动向一端，然后直接清除掉边界外的内存。
     *
     * 4. 分代收集算法—常见虚拟机的方式
     * 分代收集算法就是综合2、3，对于堆中的不同区域使用不同的收集算法。
     */
}
