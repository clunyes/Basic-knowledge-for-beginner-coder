package structural_design_pattern;


public class conclude {

    public void diffInFacdeAndMediator() {
/**
 * 代理模式
 个人理解：

 代理模式是将原类进行封装，客户端只需要与代理进行交流。代理就是原类的一个替身。简而言之就是用一个对象代表另外一个对象。强调的是个体。

 中介者模式

 定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互

 使用中介者模式的场合
 1.一组定义良好的对象，现在要进行复杂的通信。
 2.定制一个分布在多个类中的行为，而又不想生成太多的子类。
 可以看出，中介对象主要是用来封装行为的，行为的参与者就是那些对象，但是通过中介者，这些对象不用相互知道。

 使用中介者模式的优点：
 1.降低了系统对象之间的耦合性，使得对象易于独立的被复用。
 2.提高系统的灵活性，使得系统易于扩展和维护。

 使用中介者模式的缺点：
 中介者模式的缺点是显而易见的，因为这个“中介“承担了较多的责任，所以一旦这个中介对象出现了问题，那么整个系统就会受到重大的影响。


 三者的区别与联系

 1，中介者模式：A，B之间的对话通过C来传达。A,B可以互相不认识（减少了A和B对象间的耦合）
 2，代理模式：A要送B礼物，A,B互相不认识，那么A可以找C来帮它实现送礼物的愿望（封装了A对象）
 3，外观模式：A和B都要实现送花，送巧克力的方法，那么我可以通过一个抽象类C实现送花送巧克力的方法（A和B都继承C）。（封装了A，B子类）
 代理模式和外观者模式这两种模式主要不同就是代理模式针对的是单个对象，而外观模式针对的是所有子类。
 */
    }

    //adapter decorator facade proxy4个模式的区别
    public void diffIn4() {
        /**
         *适配器模式，一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。

         装饰器模式，原有的不能满足现有的需求，对原有的进行增强。

         代理模式，同一个类而去调用另一个类的方法，不对这个方法进行直接操作。

         外观模式，我们通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，这样无疑会降低应用程序的复杂度，并且提高了程序的可维护性。

         区别：
         代理模式是与原对象实现同一个接口，必须要实现原接口和持有真实的对象，才能称之为代理类。代理模式一定是自身持有这个对象，不需要从外部传入。用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。

         装饰模式的一定是从外部传入，并且可以没有顺序，按照代码的实际需求随意挑换顺序。当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

         适配器类则是匹配新接口，从代码上的特点来说，适配类持有新的目标对象（对象适配器）。

         代理模式注重的是隔离限制，关注于控制对对象的访问，让外部不能访问你实际的调用对象，比如权限控制。代理和真实对象之间的的关系通常在编译时就已经确定了。
         装饰模式注重的是功能的拓展，关注于在一个对象上动态的添加方法，在同一个方法下实现更多的功能。装饰者能够在运行时递归地被构造。
         适配器模式注重的是接口的兼容。
         外观模式注重的是多个类的集成、统一适配。
         */
    }
}
