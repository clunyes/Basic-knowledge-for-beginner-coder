package network;

public class tcpudp {
    /**
     * 服务端程序：守护进程
     *
     * tcp：面向连接（顺序控制，重发控制），可靠传输
     *
     * udp：无连接，传输更实时，不用考虑包丢失，不可靠传输
     *
     * （udp-lite 轻微错误的包，不会被抛弃）
     *
     * 这些在编程层面都要使用socket编程
     *
     * 端口号：用于区别同个ip下不同应用程序
     *
     * 如何确定唯一的tcp连接：源ip地址，目标ip地址，协议号，源端口号，目标端口号
     *
     * 程序端口号分为两种：标准既定端口号（ftp：21 ssh：22 http：80 https：443）
     * 分配法：由操作系统分配端口号
     *
     */
    /**
     * tcp的三次握手
     * 1.为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？
     * 我们来分析一种特殊情况，假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，
     * 假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的过程中数据丢失，
     * 客户端认为连接没有建立，会进行重传。假设每次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，
     * 这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪水攻击”。
     * 总结：第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，
     * 但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。
     *
     * 2.为什么是四次挥手，而不是三次或是五次、六次？
     *双方关闭连接要经过双方都同意。所以，首先是客服端给服务器发送FIN，要求关闭连接，服务器收到后会发送一个ACK进行确认。
     * 服务器然后再发送一个FIN，客户端发送ACK确认，并进入TIME_WAIT状态。等待2MSL后自动关闭
     *
     * 参考资料：https://blog.csdn.net/ZWE7616175/article/details/80432486
     */
}
